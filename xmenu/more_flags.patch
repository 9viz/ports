diff --git a/xmenu.c b/xmenu.c
index 9bc6cbe..c18868c 100644
--- a/xmenu.c
+++ b/xmenu.c
@@ -16,7 +16,7 @@
 #define MIN(a,b) (((a)<(b))?(a):(b))
 
 struct geom {
-	int x, y, w, h;
+    int x, y, w, h;
 };
 
 int verbose = 0;
@@ -34,300 +34,309 @@ char **entries;
 void
 usage(FILE *fd, char *name)
 {
-	fprintf(fd, "usage: %s [-hd] item..\n", name);
+    fprintf(fd, "usage: %s [-hdFbf] item..\n", name);
 }
 
 int
 hilight(xcb_drawable_t xid, int x, int y, int w, int h)
 {
-	int mask, val[3];
-	xcb_gcontext_t gc;
-	xcb_rectangle_t r;
+    int mask, val[3];
+    xcb_gcontext_t gc;
+    xcb_rectangle_t r;
 
-	gc = xcb_generate_id(dpy);
+    gc = xcb_generate_id(dpy);
 
-	mask = XCB_GC_FUNCTION | XCB_GC_SUBWINDOW_MODE;
-	val[0] = XCB_GX_INVERT;
-	val[1] = XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS;
-	xcb_create_gc(dpy, gc, xid, mask, val);
+    mask = XCB_GC_FUNCTION | XCB_GC_SUBWINDOW_MODE;
+    val[0] = XCB_GX_INVERT;
+    val[1] = XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS;
+    xcb_create_gc(dpy, gc, xid, mask, val);
 
-	/* draw inverted rectangle */
-	r.x = x;
-	r.y = y;
-	r.width = w;
-	r.height = h;
-	xcb_poly_fill_rectangle(dpy, xid, gc, 1, &r);
+    /* draw inverted rectangle */
+    r.x = x;
+    r.y = y;
+    r.width = w;
+    r.height = h;
+    xcb_poly_fill_rectangle(dpy, xid, gc, 1, &r);
 
-	return 0;
+    return 0;
 }
 
 int
 drawentries()
 {
-	size_t i, w, h;
+    size_t i, w, h;
 
-	for (i = 0; i < nent; i++) {
-		w = (menu.w - xft_txtw(entries[i])) / 2;
-		h = (menu.h/nent) * (i + 0.5) - maxheight/2 + (maxheight - xft_txth(entries[i]));
-		xft_drawtext(dpy, wid, w, h, foreground, entries[i]);
-	}
+    for (i = 0; i < nent; i++) {
+        w = (menu.w - xft_txtw(entries[i])) / 2;
+        h = (menu.h/nent) * (i + 0.5) - maxheight/2 + (maxheight - xft_txth(entries[i]));
+        xft_drawtext(dpy, wid, w, h, foreground, entries[i]);
+    }
 
-	return 0;
+    return 0;
 }
 
 int
 popwindow(int x, int y, int w, int h)
 {
-	int mask, val[4];
+    int mask, val[4];
 
-	mask = XCB_CW_BACK_PIXEL
-		| XCB_CW_EVENT_MASK;
+    mask = XCB_CW_BACK_PIXEL
+        | XCB_CW_EVENT_MASK;
 
-	val[0] = background;
-	val[1] = XCB_EVENT_MASK_EXPOSURE
-		| XCB_EVENT_MASK_KEY_PRESS
-		| XCB_EVENT_MASK_ENTER_WINDOW
-		| XCB_EVENT_MASK_LEAVE_WINDOW
-		| XCB_EVENT_MASK_BUTTON_RELEASE
-		| XCB_EVENT_MASK_POINTER_MOTION
-		| XCB_EVENT_MASK_STRUCTURE_NOTIFY;
+    val[0] = background;
+    val[1] = XCB_EVENT_MASK_EXPOSURE
+        | XCB_EVENT_MASK_KEY_PRESS
+        | XCB_EVENT_MASK_ENTER_WINDOW
+        | XCB_EVENT_MASK_LEAVE_WINDOW
+        | XCB_EVENT_MASK_BUTTON_RELEASE
+        | XCB_EVENT_MASK_POINTER_MOTION
+        | XCB_EVENT_MASK_STRUCTURE_NOTIFY;
 
-	wid = xcb_generate_id(dpy);
-	xcb_create_window(dpy, screen->root_depth, wid, screen->root,
-		x, y, w, h, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT,
-		screen->root_visual, mask, val);
+    wid = xcb_generate_id(dpy);
+    xcb_create_window(dpy, screen->root_depth, wid, screen->root,
+        x, y, w, h, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT,
+        screen->root_visual, mask, val);
 
-	xcb_map_window(dpy, wid);
-	xcb_flush(dpy);
+    xcb_map_window(dpy, wid);
+    xcb_flush(dpy);
 
-	xcb_grab_pointer(dpy, 1, wid, XCB_EVENT_MASK_NO_EVENT,
-		XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC,
-		wid, XCB_NONE, XCB_CURRENT_TIME);
+    xcb_grab_pointer(dpy, 1, wid, XCB_EVENT_MASK_NO_EVENT,
+        XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC,
+        wid, XCB_NONE, XCB_CURRENT_TIME);
 
-	return 0;
+    return 0;
 }
 
 int
 eventloop()
 {
-	xcb_generic_event_t *ev;
-	xcb_motion_notify_event_t *e;
-
-	for (;;) {
-		int last = current;
-
-		ev = xcb_wait_for_event(dpy);
-		if (!ev)
-			break;
-
-		switch(ev->response_type & ~0x80) {
-
-		/*
-		 * pressing escape (keycode 9) clears the selection and
-		 * closes the menu
-		 */
-		case XCB_KEY_PRESS:
-			if (((xcb_key_press_event_t *)ev)->detail == 9) {
-				current = -1;
-				return 0;
-			}
-			break;
-
-		/*
-		 * button press events MUST be caught on root window
-		 * only to avoid popup loops
-		 */
-		case XCB_BUTTON_PRESS:
-			if (((xcb_button_press_event_t *)ev)->detail != mousebutton)
-				break;
-			menu.x = ((xcb_button_press_event_t *)ev)->root_x;
-			menu.y = ((xcb_button_press_event_t *)ev)->root_y;
-			popwindow(menu.x, menu.y, menu.w, menu.h);
-			break;
-
-		/*
-		 * releasing the mouse button closes the menu while
-		 * keeping the current selection active. In other words,
-		 * it validates the current selection (if any)
-		 */
-		case XCB_BUTTON_RELEASE:
-			if (((xcb_button_press_event_t *)ev)->detail == mousebutton)
-				return 0;
-			break;
-
-		/*
-		 * make sure to keep track of window geometry changes
-		 * to calculate cursor position correctly
-		 */
-		case XCB_CONFIGURE_NOTIFY:
-			menu.x =  ((xcb_configure_notify_event_t *)ev)->x;
-			menu.y = ((xcb_configure_notify_event_t *)ev)->y;
-			menu.w =  ((xcb_configure_notify_event_t *)ev)->width;
-			menu.h = ((xcb_configure_notify_event_t *)ev)->height;
-			break;
-
-		case XCB_EXPOSE:
-			/*
-			 * TODO: clean after someone mess up current entry
-			 * As the current entry is represented using an
-			 * XCB_GX_INVERT function, an external program
-			 * could mess up the display by drawing over
-			 * the selection using a non-inverting function.
-			 * Inverting a partially cleared region would
-			 * end up inverting the artifacts, so we must
-			 * find a way to clean up this mess somehow.
-			 *
-			 * Damn punks.
-			 */
-			if (last >= 0 && last != current)
-				hilight(wid, 0, (menu.h/nent) * last, menu.w, menu.h/nent);
-			drawentries();
-			if (current >= 0)
-				hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
-			break;
-
-		/*
-		 * moving the cursor outside the menu clears the current
-		 * selection, so that you can "cancel" the menu by releasing
-		 * the mouse outside the menu
-		 */
-		case XCB_LEAVE_NOTIFY:
-			if (current >= 0)
-				hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
-			current = -1;
-			break;
-
-		/*
-		 * calculate current item based on cursor position
-		 * relative to the root window and current window dimensions
-		 */
-		case XCB_MOTION_NOTIFY:
-			e = (xcb_motion_notify_event_t *)ev;
-			/*
-			 * in some special cases, MOTION events can be
-			 * reported in the window when the pointer is
-			 * actually outside. For example when pressing
-			 * mouse button inside the window and the moving
-			 * out while holding it.
-			 * When don't want to select an entry in such
-			 * cases, so we must check first that the pointer
-			 * is actually inside the window
-			 */
-			if (e->root_x > menu.x + menu.w
-			 || e->root_y > menu.y + menu.h
-			 || e->root_x < menu.x
-			 || e->root_y < menu.y) {
-				if (current >= 0)
-					hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
-				current = -1;
-				break;
-			}
-
-			current = nent * ((e->root_y - menu.y) * 1.0 / menu.h);
-
-			/* don't bother redrawing selection that didn't change */
-			if (last == current)
-				break;
-			if (last >= 0)
-				hilight(wid, 0, (menu.h/nent) * last, menu.w, menu.h/nent);
-			if (current >= 0)
-				hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
-			break;
-		}
-
-		xcb_flush(dpy);
-		free(ev);
-	}
-
-	return -1;
+    xcb_generic_event_t *ev;
+    xcb_motion_notify_event_t *e;
+
+    for (;;) {
+        int last = current;
+
+        ev = xcb_wait_for_event(dpy);
+        if (!ev)
+            break;
+
+        switch(ev->response_type & ~0x80) {
+
+        /*
+         * pressing escape (keycode 9) clears the selection and
+         * closes the menu
+         */
+        case XCB_KEY_PRESS:
+            if (((xcb_key_press_event_t *)ev)->detail == 9) {
+                current = -1;
+                return 0;
+            }
+            break;
+
+        /*
+         * button press events MUST be caught on root window
+         * only to avoid popup loops
+         */
+        case XCB_BUTTON_PRESS:
+            if (((xcb_button_press_event_t *)ev)->detail != mousebutton)
+                break;
+            menu.x = ((xcb_button_press_event_t *)ev)->root_x;
+            menu.y = ((xcb_button_press_event_t *)ev)->root_y;
+            popwindow(menu.x, menu.y, menu.w, menu.h);
+            break;
+
+        /*
+         * releasing the mouse button closes the menu while
+         * keeping the current selection active. In other words,
+         * it validates the current selection (if any)
+         */
+        case XCB_BUTTON_RELEASE:
+            if (((xcb_button_press_event_t *)ev)->detail == mousebutton)
+                return 0;
+            break;
+
+        /*
+         * make sure to keep track of window geometry changes
+         * to calculate cursor position correctly
+         */
+        case XCB_CONFIGURE_NOTIFY:
+            menu.x =  ((xcb_configure_notify_event_t *)ev)->x;
+            menu.y = ((xcb_configure_notify_event_t *)ev)->y;
+            menu.w =  ((xcb_configure_notify_event_t *)ev)->width;
+            menu.h = ((xcb_configure_notify_event_t *)ev)->height;
+            break;
+
+        case XCB_EXPOSE:
+            /*
+             * TODO: clean after someone mess up current entry
+             * As the current entry is represented using an
+             * XCB_GX_INVERT function, an external program
+             * could mess up the display by drawing over
+             * the selection using a non-inverting function.
+             * Inverting a partially cleared region would
+             * end up inverting the artifacts, so we must
+             * find a way to clean up this mess somehow.
+             *
+             * Damn punks.
+             */
+            if (last >= 0 && last != current)
+                hilight(wid, 0, (menu.h/nent) * last, menu.w, menu.h/nent);
+            drawentries();
+            if (current >= 0)
+                hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
+            break;
+
+        /*
+         * moving the cursor outside the menu clears the current
+         * selection, so that you can "cancel" the menu by releasing
+         * the mouse outside the menu
+         */
+        case XCB_LEAVE_NOTIFY:
+            if (current >= 0)
+                hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
+            current = -1;
+            break;
+
+        /*
+         * calculate current item based on cursor position
+         * relative to the root window and current window dimensions
+         */
+        case XCB_MOTION_NOTIFY:
+            e = (xcb_motion_notify_event_t *)ev;
+            /*
+             * in some special cases, MOTION events can be
+             * reported in the window when the pointer is
+             * actually outside. For example when pressing
+             * mouse button inside the window and the moving
+             * out while holding it.
+             * When don't want to select an entry in such
+             * cases, so we must check first that the pointer
+             * is actually inside the window
+             */
+            if (e->root_x > menu.x + menu.w
+             || e->root_y > menu.y + menu.h
+             || e->root_x < menu.x
+             || e->root_y < menu.y) {
+                if (current >= 0)
+                    hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
+                current = -1;
+                break;
+            }
+
+            current = nent * ((e->root_y - menu.y) * 1.0 / menu.h);
+
+            /* don't bother redrawing selection that didn't change */
+            if (last == current)
+                break;
+            if (last >= 0)
+                hilight(wid, 0, (menu.h/nent) * last, menu.w, menu.h/nent);
+            if (current >= 0)
+                hilight(wid, 0, (menu.h/nent) * current, menu.w, menu.h/nent);
+            break;
+        }
+
+        xcb_flush(dpy);
+        free(ev);
+    }
+
+    return -1;
 }
 
 int
 main(int argc, char *argv[])
 {
-	int dflag = 0;
-	long dpi;
-	char *argv0;
-
-	ARGBEGIN {
-	case 'd':
-		dflag = 1;
-		break;
-	case 'h':
-		usage(stdout, argv0);
-		return 0;
-		break;
-	case 'v':
-		verbose++;
-		break;
-	default:
-		usage(stderr, argv0);
-		return -1;
-		break;
-	} ARGEND;
-
-	if (!argc) {
-		usage(stderr, argv0);
-		return -1;
-	}
-
-	dpy = xcb_connect(NULL, NULL);
-	if (xcb_connection_has_error(dpy))
-		return -1;
-
-	screen = xcb_setup_roots_iterator(xcb_get_setup(dpy)).data;
-	if (!screen)
-		return -1;
-
-	/* 1 inch = 25.4 millimeters */
-	dpi = screen->height_in_pixels/screen->height_in_millimeters * 25.4;
-
-	xft_loadfont(font, dpi);
-
-	entries = argv;
-	for (nent = 0; nent < (size_t)argc; nent++) {
-		maxwidth  = MAX(xft_txtw(entries[nent]), maxwidth);
-		maxheight = MAX(xft_txth(entries[nent]), maxheight);
-	}
-
-	menu.w = maxwidth * 1.5;
-	menu.h = maxheight * nent * 2;
-
-	/*
-	 * daemon mode will catch mouse clicks on the root window and
-	 * pop the menu everytime it is clicked.
-	 * selection happens instantly and is validated upon releasing
-	 * the mouse button while hovering an item
-	 */
-	if (dflag) {
-		int val[] = {
-			XCB_EVENT_MASK_BUTTON_PRESS
-			| XCB_EVENT_MASK_BUTTON_RELEASE
-			| XCB_EVENT_MASK_POINTER_MOTION
-		};
-
-		xcb_change_window_attributes(dpy, screen->root, XCB_CW_EVENT_MASK, val);
-		xcb_flush(dpy);
-
-		for (;;) {
-			current = -1;
-			eventloop();
-			if (current >= 0) {
-				printf("%s\n", entries[current]);
-				fflush(stdout);
-			}
-
-			xcb_destroy_window(dpy, wid);
-		}
-	}
-
-	popwindow(menu.x, menu.y, menu.w, menu.h);
-	eventloop();
-	if (current >= 0)
-		printf("%s\n", entries[current]);
-
-	xcb_destroy_window(dpy, wid);
-	xft_unload();
-	xcb_disconnect(dpy);
-	return 0;
+    int dflag = 0;
+    long dpi;
+    char *argv0;
+
+    ARGBEGIN {
+    case 'd':
+        dflag = 1;
+        break;
+    case 'F':
+        font = EARGF(usage(stdout, argv0));
+        break;
+    case 'b':
+        background = strtoul(EARGF(usage(stdout, argv0)), NULL, 16);
+        break;
+    case 'f':
+        foreground = strtoul(EARGF(usage(stdout, argv0)), NULL, 16);
+        break;
+    case 'h':
+        usage(stdout, argv0);
+        return 0;
+        break;
+    case 'v':
+        verbose++;
+        break;
+    default:
+        usage(stderr, argv0);
+        return -1;
+        break;
+    } ARGEND;
+
+    if (!argc) {
+        usage(stderr, argv0);
+        return -1;
+    }
+
+    dpy = xcb_connect(NULL, NULL);
+    if (xcb_connection_has_error(dpy))
+        return -1;
+
+    screen = xcb_setup_roots_iterator(xcb_get_setup(dpy)).data;
+    if (!screen)
+        return -1;
+
+    /* 1 inch = 25.4 millimeters */
+    dpi = screen->height_in_pixels/screen->height_in_millimeters * 25.4;
+
+    xft_loadfont(font, dpi);
+
+    entries = argv;
+    for (nent = 0; nent < (size_t)argc; nent++) {
+        maxwidth  = MAX(xft_txtw(entries[nent]), maxwidth);
+        maxheight = MAX(xft_txth(entries[nent]), maxheight);
+    }
+
+    menu.w = maxwidth * 1.5;
+    menu.h = maxheight * nent * 2;
+
+    /*
+     * daemon mode will catch mouse clicks on the root window and
+     * pop the menu everytime it is clicked.
+     * selection happens instantly and is validated upon releasing
+     * the mouse button while hovering an item
+     */
+    if (dflag) {
+        int val[] = {
+            XCB_EVENT_MASK_BUTTON_PRESS
+            | XCB_EVENT_MASK_BUTTON_RELEASE
+            | XCB_EVENT_MASK_POINTER_MOTION
+        };
+
+        xcb_change_window_attributes(dpy, screen->root, XCB_CW_EVENT_MASK, val);
+        xcb_flush(dpy);
+
+        for (;;) {
+            current = -1;
+            eventloop();
+            if (current >= 0) {
+                printf("%s\n", entries[current]);
+                fflush(stdout);
+            }
+
+            xcb_destroy_window(dpy, wid);
+        }
+    }
+
+    popwindow(menu.x, menu.y, menu.w, menu.h);
+    eventloop();
+    if (current >= 0)
+        printf("%s\n", entries[current]);
+
+    xcb_destroy_window(dpy, wid);
+    xft_unload();
+    xcb_disconnect(dpy);
+    return 0;
 }
